<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 播放與剪輯工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #fafafa;
            border-radius: 10px;
            border: 1px solid #eee;
        }

        .section-title {
            font-size: 1.3rem;
            color: #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .file-upload-area {
            border: 3px dashed #bbb;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-icon {
            font-size: 3rem;
            color: #bbb;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1rem;
            color: #666;
        }

        input[type="file"] {
            display: none;
        }

        .file-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin-top: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            outline: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* 強制前進後退按鈕始終可點擊 */
        #rewindBtn, #forwardBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            cursor: pointer !important;
            pointer-events: auto !important;
        }
        
        #rewindBtn:hover, #forwardBtn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4) !important;
        }

        .progress-container {
            background: #eee;
            border-radius: 25px;
            padding: 3px;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .progress-bar::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .time-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 15px;
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .trim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .trim-input {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .trim-input label {
            font-weight: bold;
            color: #555;
        }

        .trim-input input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .trim-input input:focus {
            border-color: #667eea;
        }

        .download-section {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .download-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            font-size: 1.1rem;
            padding: 15px 30px;
        }

        .download-btn:hover {
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            margin: 10px 0;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
            margin: 10px 0;
        }

        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .trim-controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 MP3 播放與剪輯工具</h1>
            <p>上傳音檔、播放、剪輯，然後下載您的作品</p>
        </div>

        <div class="content">
            <!-- 檔案上傳區 -->
            <div class="section">
                <h2 class="section-title">📁 上傳音檔</h2>
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">🎧</div>
                    <div class="upload-text">
                        <strong>點擊或拖拽 MP3 檔案到這裡</strong><br>
                        支援格式：MP3, WAV, M4A
                    </div>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>
                <div id="fileInfo" class="file-info" style="display: none;">
                    <div id="fileName"></div>
                    <div id="fileDuration"></div>
                </div>
                <div id="errorMessage" class="error-message" style="display: none;"></div>
            </div>

            <!-- 播放控制區 -->
            <div class="section" id="playerSection" style="display: none;">
                <h2 class="section-title">🎮 播放控制</h2>
                
                <div class="controls">
                    <button class="btn" id="playBtn">▶️ 播放</button>
                    <button class="btn" id="pauseBtn" disabled>⏸️ 暫停</button>
                    <button class="btn" id="rewindBtn">⏪ -5秒</button>
                    <button class="btn" id="forwardBtn">⏩ +5秒</button>
                </div>

                <div class="progress-container">
                    <input type="range" class="progress-bar" id="progressBar" min="0" max="100" value="0">
                </div>

                <!-- 波形可視化 -->
                <canvas id="waveform" width="720" height="100" style="width: 100%; height: 100px; background: #f8f9fa; border-radius: 8px; margin: 10px 0;"></canvas>

                <div class="time-info">
                    <span id="currentTime">00:00</span>
                    <span id="totalTime">00:00</span>
                </div>

                <div class="volume-container">
                    <span>🔊</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                    <span id="volumeValue">50%</span>
                </div>
            </div>

            <!-- 剪輯控制區 -->
            <div class="section" id="trimSection" style="display: none;">
                <h2 class="section-title">✂️ 剪輯設定</h2>
                
                <div class="trim-controls">
                    <div class="trim-input">
                        <label for="startTime">開始時間 (秒)</label>
                        <input type="number" id="startTime" min="0" step="0.1" placeholder="0.0">
                    </div>
                    <div class="trim-input">
                        <label for="endTime">結束時間 (秒)</label>
                        <input type="number" id="endTime" min="0" step="0.1" placeholder="10.0">
                    </div>
                </div>

                <div class="trim-controls">
                    <div class="trim-input">
                        <label for="fadeInTime">淡入時間 (秒)</label>
                        <input type="number" id="fadeInTime" min="0" max="5" step="0.1" value="0" placeholder="0.0">
                    </div>
                    <div class="trim-input">
                        <label for="fadeOutTime">淡出時間 (秒)</label>
                        <input type="number" id="fadeOutTime" min="0" max="5" step="0.1" value="0" placeholder="0.0">
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" id="previewBtn">🔍 預覽剪輯</button>
                    <button class="btn" id="resetBtn">🔄 重置</button>
                    <button class="btn" id="setStartBtn">📍 設為開始</button>
                    <button class="btn" id="setEndBtn">📍 設為結束</button>
                </div>
            </div>

            <!-- 下載區 -->
            <div class="section" id="downloadSection" style="display: none;">
                <h2 class="section-title">💾 下載剪輯</h2>
                <div class="download-section">
                    <button class="btn download-btn" id="downloadWavBtn">📥 下載 WAV 檔案</button>
                    <button class="btn download-btn" id="downloadMp3Btn" style="margin-left: 15px;">📥 下載 MP3 檔案</button>
                </div>
                <div id="successMessage" class="success-message" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- 加入 LameJS 庫用於 MP3 編碼 - 320kbps 高音質 -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    
    <script>
        // 全域變數
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let gainNode;
        let isPlaying = false;
        let startOffset = 0; // 當前播放偏移（秒）
        let startTime = 0;   // 開始播放的時間（context 時間）
        let animationId;
        let waveformData = null;
        let previewEndTime = null; // 預覽模式的結束時間
        let fadeInTime = 0; // 預覽淡入時間
        let fadeOutTime = 0; // 預覽淡出時間
        let previewStartTime = 0; // 預覽開始時間

        // DOM 元素
        const uploadArea = document.getElementById('uploadArea');
        const audioFile = document.getElementById('audioFile');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileDuration = document.getElementById('fileDuration');
        const errorMessage = document.getElementById('errorMessage');
        const successMessage = document.getElementById('successMessage');
        
        const playerSection = document.getElementById('playerSection');
        const trimSection = document.getElementById('trimSection');
        const downloadSection = document.getElementById('downloadSection');
        
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');
        const fadeInTimeInput = document.getElementById('fadeInTime');
        const fadeOutTimeInput = document.getElementById('fadeOutTime');
        const previewBtn = document.getElementById('previewBtn');
        const resetBtn = document.getElementById('resetBtn');
        const setStartBtn = document.getElementById('setStartBtn');
        const setEndBtn = document.getElementById('setEndBtn');
        const downloadWavBtn = document.getElementById('downloadWavBtn');
        const downloadMp3Btn = document.getElementById('downloadMp3Btn');
        const waveformCanvas = document.getElementById('waveform');

        // 初始化 AudioContext
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0.5; // 預設音量 50%
            }
        }

        // 檢查 LameJS 庫加載狀態
        function checkLameJS() {
            if (typeof lamejs === 'undefined') {
                console.warn('LameJS 庫未加載，MP3功能將不可用');
                return false;
            } else {
                console.log('LameJS 庫已加載，支援MP3編碼');
                return true;
            }
        }

        // 頁面加載完成後檢查
        window.addEventListener('load', () => {
            setTimeout(checkLameJS, 1000); // 延遲檢查確保庫已加載
        });
        

        // 格式化時間
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // 顯示錯誤訊息
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 5000);
        }

        // 顯示成功訊息
        function showSuccess(message) {
            successMessage.textContent = message;
            successMessage.style.display = 'block';
            setTimeout(() => {
                successMessage.style.display = 'none';
            }, 3000);
        }

        // 生成波形數據
        function generateWaveformData(buffer, width = 720) {
            const channelData = buffer.getChannelData(0); // 使用第一個聲道
            const samplesPerPixel = Math.floor(channelData.length / width);
            const waveform = new Array(width);
            
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                
                for (let j = 0; j < samplesPerPixel; j++) {
                    const sample = channelData[i * samplesPerPixel + j] || 0;
                    if (sample < min) min = sample;
                    if (sample > max) max = sample;
                }
                
                waveform[i] = { min, max };
            }
            
            return waveform;
        }

        // 繪製波形
        function drawWaveform(waveform, currentProgress = 0) {
            if (!waveformCanvas) return;
            
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;
            
            // 清除畫布
            ctx.clearRect(0, 0, width, height);
            
            // 繪製背景波形（灰色）
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < waveform.length; i++) {
                const x = (i / waveform.length) * width;
                const yMin = centerY + (waveform[i].min * centerY * 0.8);
                const yMax = centerY + (waveform[i].max * centerY * 0.8);
                
                ctx.moveTo(x, yMin);
                ctx.lineTo(x, yMax);
            }
            ctx.stroke();
            
            // 繪製已播放部分（藍色）
            const playedWidth = width * currentProgress;
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < waveform.length && (i / waveform.length) * width <= playedWidth; i++) {
                const x = (i / waveform.length) * width;
                const yMin = centerY + (waveform[i].min * centerY * 0.8);
                const yMax = centerY + (waveform[i].max * centerY * 0.8);
                
                ctx.moveTo(x, yMin);
                ctx.lineTo(x, yMax);
            }
            ctx.stroke();
            
            // 繪製播放位置指示線
            if (currentProgress > 0) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playedWidth, 0);
                ctx.lineTo(playedWidth, height);
                ctx.stroke();
            }
        }

        // 檔案拖拽處理
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            audioFile.click();
        });

        audioFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // 處理上傳的檔案
        async function handleFile(file) {
            if (!file.type.startsWith('audio/')) {
                showError('請選擇音訊檔案！');
                return;
            }

            try {
                initAudioContext();
                
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // 生成波形數據
                waveformData = generateWaveformData(audioBuffer);
                drawWaveform(waveformData, 0);
                
                // 顯示檔案資訊
                fileName.textContent = `檔案：${file.name}`;
                fileDuration.textContent = `長度：${formatTime(audioBuffer.duration)}`;
                fileInfo.style.display = 'block';
                
                // 設定預設剪輯時間
                startTimeInput.max = audioBuffer.duration;
                endTimeInput.max = audioBuffer.duration;
                endTimeInput.value = Math.min(10, audioBuffer.duration);
                
                // 更新進度條最大值
                progressBar.max = 100;
                totalTime.textContent = formatTime(audioBuffer.duration);
                
                // 顯示控制區域
                playerSection.style.display = 'block';
                trimSection.style.display = 'block';
                downloadSection.style.display = 'block';
                
                // 確保所有控制按鈕的初始狀態正確
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
            } catch (error) {
                console.error('音訊解碼錯誤:', error);
                showError('音訊檔案格式不支援或檔案損壞！');
            }
        }

        // 強制停止並清理 sourceNode - 確保永遠只有一個音軌
        function forceStopSourceNode() {
            console.log('執行強制停止 - sourceNode存在:', !!sourceNode, 'isPlaying:', isPlaying);
            
            if (sourceNode) {
                try {
                    // 移除事件監聽器防止意外觸發
                    sourceNode.onended = null;
                    sourceNode.stop();
                    console.log('sourceNode.stop() 成功');
                } catch (e) {
                    console.warn('sourceNode 停止失敗:', e);
                }
                
                try {
                    sourceNode.disconnect();
                    console.log('sourceNode.disconnect() 成功');
                } catch (e) {
                    console.warn('sourceNode 斷連失敗:', e);
                }
                
                sourceNode = null;
                console.log('sourceNode 已設為 null');
            }
            
            // 強制重置狀態
            isPlaying = false;
            cancelAnimationFrame(animationId);
            
            console.log('音軌清理完成 - 確保只有一個音軌');
        }

        // 播放音訊
        function playAudio(offset = startOffset) {
            if (!audioBuffer) return;

            // 1. 先檢查並強制停止舊的 sourceNode
            forceStopSourceNode();
            
            try {
                // 2. 建立新的 AudioBufferSourceNode
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(gainNode);
                
                // 3. 從正確的 offset 開始播放
                sourceNode.start(0, offset);
                
                // 4. 記錄開始時間和偏移
                startTime = audioContext.currentTime;
                startOffset = offset;
                isPlaying = true;
                
                // 5. 更新按鈕狀態
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
                // 6. 開始更新進度
                updateProgress();
                
                // 7. 播放結束時的處理
                sourceNode.onended = () => {
                    if (isPlaying && sourceNode) {
                        isPlaying = false;
                        playBtn.disabled = false;
                        pauseBtn.disabled = true;
                        sourceNode = null;
                        cancelAnimationFrame(animationId);
                    }
                };
            } catch (error) {
                console.error('播放錯誤:', error);
                forceStopSourceNode();
                showError('播放失敗，請稍後再試！');
            }
        }

        // 預覽播放 - 帶即時淡入淡出效果
        function playAudioWithFade(offset, fadeInDuration = 0, fadeOutDuration = 0, endTime = null) {
            if (!audioBuffer) return;

            console.log(`預覽播放: 從${offset}s, 淡入${fadeInDuration}s, 淡出${fadeOutDuration}s`);

            // 1. 先檢查並強制停止舊的 sourceNode
            forceStopSourceNode();
            
            try {
                // 2. 建立新的 AudioBufferSourceNode
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(gainNode);
                
                // 3. 設定淡入效果
                if (fadeInDuration > 0) {
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(
                        parseFloat(volumeSlider.value) / 100, 
                        audioContext.currentTime + fadeInDuration
                    );
                } else {
                    gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
                }
                
                // 4. 設定淡出效果
                if (fadeOutDuration > 0 && endTime) {
                    const fadeOutStartTime = audioContext.currentTime + (endTime - offset) - fadeOutDuration;
                    if (fadeOutStartTime > audioContext.currentTime) {
                        gainNode.gain.setValueAtTime(
                            parseFloat(volumeSlider.value) / 100, 
                            fadeOutStartTime
                        );
                        gainNode.gain.linearRampToValueAtTime(0, fadeOutStartTime + fadeOutDuration);
                    }
                }
                
                // 5. 從正確的 offset 開始播放
                sourceNode.start(0, offset);
                
                // 6. 記錄開始時間和偏移
                startTime = audioContext.currentTime;
                startOffset = offset;
                isPlaying = true;
                
                // 7. 更新按鈕狀態
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
                // 8. 開始更新進度
                updateProgress();
                
                // 9. 播放結束時的處理
                sourceNode.onended = () => {
                    if (isPlaying && sourceNode) {
                        isPlaying = false;
                        playBtn.disabled = false;
                        pauseBtn.disabled = true;
                        sourceNode = null;
                        // 恢復原始音量
                        gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
                        cancelAnimationFrame(animationId);
                    }
                };
            } catch (error) {
                console.error('預覽播放錯誤:', error);
                forceStopSourceNode();
                showError('預覽播放失敗，請稍後再試！');
            }
        }

        // 暫停音訊 - 強制停止所有音軌
        function pauseAudio() {
            // 1. 無論什麼狀態，都強制停止所有音軌
            if (isPlaying && sourceNode) {
                // 計算當前播放位置
                startOffset += audioContext.currentTime - startTime;
            }
            
            // 2. 清除預覽模式
            previewEndTime = null;
            fadeInTime = 0;
            fadeOutTime = 0;
            previewStartTime = 0;
            
            // 3. 恢復正常音量
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
            }
            
            // 4. 強制停止並清理
            forceStopSourceNode();
            
            // 5. 確保狀態正確
            isPlaying = false;
            
            // 6. 更新按鈕狀態
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
            forwardBtn.disabled = false;
            
            console.log('暫停完成 - 所有音軌已停止，音量已恢復');
        }

        // 停止音訊
        function stopAudio() {
            // 1. 清除預覽模式
            previewEndTime = null;
            
            // 2. 強制停止 sourceNode
            forceStopSourceNode();
            
            // 3. 重置播放位置
            startOffset = 0;
            startTime = 0;
            
            // 4. 更新按鈕狀態
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
            forwardBtn.disabled = false;
            
            // 5. 重置UI顯示
            progressBar.value = 0;
            currentTime.textContent = '00:00';
            
            // 6. 重繪波形（移除播放指示線）
            if (waveformData) {
                drawWaveform(waveformData, 0);
            }
        }

        // 更新播放進度
        function updateProgress() {
            if (!isPlaying || !audioBuffer) return;
            
            const elapsed = audioContext.currentTime - startTime + startOffset;
            const progress = elapsed / audioBuffer.duration;
            progressBar.value = progress * 100;
            currentTime.textContent = formatTime(elapsed);
            
            // 更新波形顯示
            if (waveformData) {
                drawWaveform(waveformData, progress);
            }
            
            // 檢查是否到達預覽結束時間
            if (previewEndTime !== null && elapsed >= previewEndTime) {
                console.log('預覽到達結束時間，自動暫停');
                previewEndTime = null; // 清除預覽模式
                pauseAudio();
                return;
            }
            
            if (elapsed < audioBuffer.duration && isPlaying) {
                animationId = requestAnimationFrame(updateProgress);
            }
        }

        // 進度條拖拽 - 拖曳時必須暫停所有音軌
        progressBar.addEventListener('input', (e) => {
            if (!audioBuffer) return;
            
            const newTime = (parseFloat(e.target.value) / 100) * audioBuffer.duration;
            const wasPlaying = isPlaying;
            
            console.log('進度條拖曳 - 強制暫停所有音軌');
            
            // 1. 強制暫停所有音軌（不論之前狀態）
            pauseAudio();
            
            // 2. 更新位置到拖曳的位置
            startOffset = newTime;
            currentTime.textContent = formatTime(newTime);
            
            // 3. 更新波形顯示
            if (waveformData) {
                drawWaveform(waveformData, newTime / audioBuffer.duration);
            }
            
            // 4. 如果之前正在播放，重新開始播放
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newTime);
                }, 10); // 短暫延遲確保清理完成
            }
        });

        // 波形canvas點擊跳轉 - 點擊時必須暫停所有音軌
        waveformCanvas.addEventListener('click', (e) => {
            if (!audioBuffer || !waveformData) return;
            
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const progress = x / rect.width;
            const newTime = progress * audioBuffer.duration;
            const wasPlaying = isPlaying;
            
            console.log('波形點擊 - 強制暫停所有音軌');
            
            // 1. 強制暫停所有音軌
            pauseAudio();
            
            // 2. 更新位置和UI
            startOffset = newTime;
            progressBar.value = progress * 100;
            currentTime.textContent = formatTime(newTime);
            drawWaveform(waveformData, progress);
            
            // 3. 如果之前正在播放，重新開始播放
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newTime);
                }, 10); // 短暫延遲確保清理完成
            }
        });

        // 音量控制 - 只調整 GainNode，不重建 sourceNode
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            volumeValue.textContent = e.target.value + '%';
            
            // 直接調整 GainNode 的音量，不需要停止或重建 sourceNode
            if (gainNode) {
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            }
        });

        // 播放控制事件
        playBtn.addEventListener('click', () => {
            // 嚴格檢查：只有在完全沒有播放時才允許
            if (!isPlaying && !sourceNode && !playBtn.disabled) {
                console.log('開始播放');
                // 清除預覽模式，恢復正常播放
                previewEndTime = null;
                playAudio();
            } else {
                console.log('播放被阻止 - 已有音軌在播放');
            }
        });

        pauseBtn.addEventListener('click', () => {
            console.log('暫停按鈕被點擊');
            pauseAudio(); // 無條件執行暫停
        });
        
        // 後退5秒
        rewindBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('請先上傳音檔！');
                return;
            }
            
            console.log('後退5秒 - 開始處理');
            
            // 1. 計算當前位置
            let currentPos = startOffset;
            const wasPlaying = isPlaying;
            if (sourceNode && isPlaying) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            // 2. 強制暫停所有音軌
            pauseAudio();
            
            // 3. 計算新的位置
            let newOffset = currentPos - 5;
            if (newOffset < 0) newOffset = 0;
            
            // 4. 更新UI狀態
            startOffset = newOffset;
            progressBar.value = (newOffset / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(newOffset);
            if (waveformData) {
                drawWaveform(waveformData, newOffset / audioBuffer.duration);
            }
            
            // 5. 如果之前在播放，重新播放
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newOffset);
                }, 10);
            }
        });
        
        // 前進5秒
        forwardBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('請先上傳音檔！');
                return;
            }
            
            console.log('前進5秒 - 開始處理');
            
            // 1. 計算當前位置
            let currentPos = startOffset;
            const wasPlaying = isPlaying;
            if (sourceNode && isPlaying) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            // 2. 強制暫停所有音軌
            pauseAudio();
            
            // 3. 計算新的位置
            let newOffset = currentPos + 5;
            if (newOffset >= audioBuffer.duration) newOffset = audioBuffer.duration - 0.1;
            
            // 4. 更新UI狀態
            startOffset = newOffset;
            progressBar.value = (newOffset / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(newOffset);
            if (waveformData) {
                drawWaveform(waveformData, newOffset / audioBuffer.duration);
            }
            
            // 5. 如果之前在播放，重新播放
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newOffset);
                }, 10);
            }
        });

        // 預覽剪輯 - 跳到剪輯開始時間並播放，帶淡入淡出效果，到結束時間自動暫停
        previewBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('請先上傳音檔！');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            const fadeIn = parseFloat(fadeInTimeInput.value) || 0;
            const fadeOut = parseFloat(fadeOutTimeInput.value) || 0;
            
            if (start >= end) {
                showError('開始時間必須小於結束時間！');
                return;
            }
            
            if (end > audioBuffer.duration) {
                showError('結束時間不能超過音檔長度！');
                return;
            }
            
            console.log(`預覽剪輯 - 從 ${start.toFixed(1)}s 到 ${end.toFixed(1)}s (淡入${fadeIn}s, 淡出${fadeOut}s)`);
            
            // 1. 強制暫停所有音軌
            pauseAudio();
            
            // 2. 設定預覽參數
            previewEndTime = end;
            previewStartTime = start;
            fadeInTime = fadeIn;
            fadeOutTime = fadeOut;
            
            // 3. 跳到剪輯開始時間
            startOffset = start;
            progressBar.value = (start / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(start);
            if (waveformData) {
                drawWaveform(waveformData, start / audioBuffer.duration);
            }
            
            // 4. 開始播放剪輯段落（帶淡入淡出效果）
            setTimeout(() => {
                playAudioWithFade(start, fadeIn, fadeOut, end);
            }, 10);
        });

        // 重置剪輯設定
        resetBtn.addEventListener('click', () => {
            console.log('重置剪輯設定');
            
            // 1. 重置剪輯參數
            startTimeInput.value = 0;
            endTimeInput.value = Math.min(10, audioBuffer ? audioBuffer.duration : 10);
            fadeInTimeInput.value = 0;
            fadeOutTimeInput.value = 0;
            
            // 2. 停止音軌並重置到開頭
            stopAudio();
        });
        
        // 設定當前時間為開始時間
        setStartBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            
            // 計算當前播放位置
            let currentPos = startOffset;
            if (isPlaying && sourceNode) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            startTimeInput.value = Math.max(0, currentPos).toFixed(1);
            console.log('設定開始時間為:', currentPos.toFixed(1));
        });
        
        // 設定當前時間為結束時間
        setEndBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            
            // 計算當前播放位置
            let currentPos = startOffset;
            if (isPlaying && sourceNode) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            endTimeInput.value = Math.min(audioBuffer.duration, currentPos).toFixed(1);
            console.log('設定結束時間為:', currentPos.toFixed(1));
        });

        // 下載剪輯音檔 (WAV)
        downloadWavBtn.addEventListener('click', async () => {
            if (!audioBuffer) {
                showError('請先上傳音檔！');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            
            if (start >= end) {
                showError('開始時間必須小於結束時間！');
                return;
            }
            
            try {
                // 建立新的 AudioBuffer 包含剪輯部分
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                const trimmedLength = endSample - startSample;
                
                console.log(`WAV下載: 開始樣本=${startSample}, 結束樣本=${endSample}, 長度=${trimmedLength}`);
                
                if (trimmedLength <= 0) {
                    showError('剪輯長度無效！');
                    return;
                }
                
                const trimmedBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    trimmedLength,
                    audioBuffer.sampleRate
                );
                
                let maxSample = 0;
                
                // 複製音訊資料
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const originalData = audioBuffer.getChannelData(channel);
                    const trimmedData = trimmedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < trimmedLength; i++) {
                        const sourceIndex = startSample + i;
                        if (sourceIndex < originalData.length) {
                            trimmedData[i] = originalData[sourceIndex];
                            maxSample = Math.max(maxSample, Math.abs(trimmedData[i]));
                        }
                    }
                }
                
                console.log(`音頻複製完成: 最大樣本值=${maxSample.toFixed(4)}`);
                
                // 應用淡入淡出效果
                const fadeInDuration = parseFloat(fadeInTimeInput.value) || 0;
                const fadeOutDuration = parseFloat(fadeOutTimeInput.value) || 0;
                
                let processedBuffer = trimmedBuffer;
                if (fadeInDuration > 0 || fadeOutDuration > 0) {
                    processedBuffer = applyFadeEffect(trimmedBuffer, fadeInDuration, fadeOutDuration);
                }
                
                // 轉換為 WAV 格式
                const wavBlob = audioBufferToWav(processedBuffer);
                
                // 建立下載連結
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `trimmed_audio_${Date.now()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showSuccess('音檔下載成功！');
                
            } catch (error) {
                console.error('下載錯誤:', error);
                showError('下載失敗，請稍後再試！');
            }
        });

        // 將 AudioBuffer 轉換為 WAV Blob
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const numberOfChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(arrayBuffer);
            
            console.log(`轉換WAV: 長度=${length}, 聲道=${numberOfChannels}, 採樣率=${sampleRate}`);
            
            // WAV 檔案標頭
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);
            
            // 音訊資料 - 修復音頻數據轉換
            let offset = 44;
            let maxSample = 0;
            
            if (numberOfChannels === 1) {
                // 單聲道
                const channelData = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    maxSample = Math.max(maxSample, Math.abs(sample));
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            } else {
                // 多聲道 - 交錯排列
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        maxSample = Math.max(maxSample, Math.abs(sample));
                        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, intSample, true);
                        offset += 2;
                    }
                }
            }
            
            console.log(`WAV轉換完成: 最大音頻值=${maxSample.toFixed(4)}`);
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        // 應用淡入淡出效果
        function applyFadeEffect(buffer, fadeInDuration, fadeOutDuration) {
            const sampleRate = buffer.sampleRate;
            const fadeInSamples = Math.floor(fadeInDuration * sampleRate);
            const fadeOutSamples = Math.floor(fadeOutDuration * sampleRate);
            const totalSamples = buffer.length;
            
            console.log(`應用淡入淡出: 淡入${fadeInSamples}樣本, 淡出${fadeOutSamples}樣本, 總長${totalSamples}樣本`);
            
            // 創建一個新的buffer副本
            const newBuffer = audioContext.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );
            
            let maxOriginal = 0;
            let maxProcessed = 0;
            
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const originalData = buffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                for (let i = 0; i < totalSamples; i++) {
                    let sample = originalData[i];
                    maxOriginal = Math.max(maxOriginal, Math.abs(sample));
                    
                    // 淡入效果
                    if (i < fadeInSamples && fadeInSamples > 0) {
                        const fadeInGain = i / fadeInSamples;
                        sample *= fadeInGain;
                    }
                    
                    // 淡出效果
                    if (i >= (totalSamples - fadeOutSamples) && fadeOutSamples > 0) {
                        const fadeOutGain = (totalSamples - i) / fadeOutSamples;
                        sample *= fadeOutGain;
                    }
                    
                    newData[i] = sample;
                    maxProcessed = Math.max(maxProcessed, Math.abs(sample));
                }
            }
            
            console.log(`淡入淡出處理完成: 原始最大值=${maxOriginal.toFixed(4)}, 處理後最大值=${maxProcessed.toFixed(4)}`);
            
            return newBuffer;
        }
        
        // 下載剪輯音檔 (MP3)
        downloadMp3Btn.addEventListener('click', async () => {
            if (!audioBuffer) {
                showError('請先上傳音檔！');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            
            if (start >= end) {
                showError('開始時間必須小於結束時間！');
                return;
            }
            
            try {
                // 建立新的 AudioBuffer 包含剪輯部分
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                const trimmedLength = endSample - startSample;
                
                console.log(`MP3下載: 開始樣本=${startSample}, 結束樣本=${endSample}, 長度=${trimmedLength}`);
                
                if (trimmedLength <= 0) {
                    showError('剪輯長度無效！');
                    return;
                }
                
                const trimmedBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    trimmedLength,
                    audioBuffer.sampleRate
                );
                
                let maxSample = 0;
                
                // 複製音訊資料
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const originalData = audioBuffer.getChannelData(channel);
                    const trimmedData = trimmedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < trimmedLength; i++) {
                        const sourceIndex = startSample + i;
                        if (sourceIndex < originalData.length) {
                            trimmedData[i] = originalData[sourceIndex];
                            maxSample = Math.max(maxSample, Math.abs(trimmedData[i]));
                        }
                    }
                }
                
                console.log(`MP3音頻複製完成: 最大樣本值=${maxSample.toFixed(4)}`);
                
                // 應用淡入淡出效果
                const fadeInDuration = parseFloat(fadeInTimeInput.value) || 0;
                const fadeOutDuration = parseFloat(fadeOutTimeInput.value) || 0;
                
                let processedBuffer = trimmedBuffer;
                if (fadeInDuration > 0 || fadeOutDuration > 0) {
                    processedBuffer = applyFadeEffect(trimmedBuffer, fadeInDuration, fadeOutDuration);
                }
                
                // 轉換為 MP3 格式
                const mp3Blob = audioBufferToMp3(processedBuffer);
                
                // 建立下載連結
                const url = URL.createObjectURL(mp3Blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `trimmed_audio_${Date.now()}.mp3`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showSuccess('MP3 音檔下載成功！');
                
            } catch (error) {
                console.error('MP3 下載錯誤:', error);
                showError('MP3 下載失敗，請稍後再試！');
            }
        });
        
        // 將 AudioBuffer 轉換為 MP3 Blob - 320kbps 高音質
        function audioBufferToMp3(buffer) {
            if (typeof lamejs === 'undefined') {
                console.warn('LameJS 未加載，將使用 WAV 格式');
                return audioBufferToWav(buffer);
            }
            
            const sampleRate = buffer.sampleRate;
            const channels = buffer.numberOfChannels;
            const length = buffer.length;
            
            console.log(`MP3編碼開始: 採樣率=${sampleRate}, 聲道=${channels}, 長度=${length}, 320kbps`);
            
            // 初始化 LAME 編碼器 - 320kbps 高音質
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 320);
            const mp3Data = [];
            
            // 處理音頻數據
            const sampleBlockSize = 1152;
            let totalSamples = 0;
            
            if (channels === 1) {
                // 單聲道處理
                const channelData = buffer.getChannelData(0);
                let maxSample = 0;
                
                for (let i = 0; i < length; i += sampleBlockSize) {
                    const blockSize = Math.min(sampleBlockSize, length - i);
                    const samples = new Int16Array(blockSize);
                    
                    for (let j = 0; j < blockSize; j++) {
                        const sample = channelData[i + j];
                        maxSample = Math.max(maxSample, Math.abs(sample));
                        // 轉換為 16 位整數，防止削峰
                        samples[j] = Math.round(Math.max(-1, Math.min(1, sample)) * 32767);
                    }
                    
                    const mp3buf = mp3encoder.encodeBuffer(samples);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                        totalSamples += blockSize;
                    }
                }
                
                console.log(`單聲道編碼: 最大樣本=${maxSample.toFixed(4)}, 處理樣本=${totalSamples}`);
                
            } else {
                // 立體聲處理
                const leftData = buffer.getChannelData(0);
                const rightData = buffer.getChannelData(1);
                let maxSampleL = 0, maxSampleR = 0;
                
                for (let i = 0; i < length; i += sampleBlockSize) {
                    const blockSize = Math.min(sampleBlockSize, length - i);
                    const leftSamples = new Int16Array(blockSize);
                    const rightSamples = new Int16Array(blockSize);
                    
                    for (let j = 0; j < blockSize; j++) {
                        const leftSample = leftData[i + j];
                        const rightSample = rightData[i + j];
                        
                        maxSampleL = Math.max(maxSampleL, Math.abs(leftSample));
                        maxSampleR = Math.max(maxSampleR, Math.abs(rightSample));
                        
                        // 轉換為 16 位整數，防止削峰
                        leftSamples[j] = Math.round(Math.max(-1, Math.min(1, leftSample)) * 32767);
                        rightSamples[j] = Math.round(Math.max(-1, Math.min(1, rightSample)) * 32767);
                    }
                    
                    const mp3buf = mp3encoder.encodeBuffer(leftSamples, rightSamples);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                        totalSamples += blockSize;
                    }
                }
                
                console.log(`立體聲編碼: 左聲道最大=${maxSampleL.toFixed(4)}, 右聲道最大=${maxSampleR.toFixed(4)}, 處理樣本=${totalSamples}`);
            }
            
            // 完成編碼
            const finalBuf = mp3encoder.flush();
            if (finalBuf.length > 0) {
                mp3Data.push(finalBuf);
            }
            
            console.log(`MP3編碼完成: 生成${mp3Data.length}個數據塊`);
            
            // 檢查是否有有效數據
            const totalBytes = mp3Data.reduce((sum, buf) => sum + buf.length, 0);
            console.log(`MP3總大小: ${totalBytes} bytes`);
            
            if (totalBytes === 0) {
                console.error('MP3編碼失敗：沒有生成有效數據');
                showError('MP3編碼失敗，請嘗試WAV格式');
                return audioBufferToWav(buffer);
            }
            
            // 創建 MP3 Blob
            return new Blob(mp3Data, { type: 'audio/mpeg' });
        }
    </script>
</body>
</html>