<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 æ’­æ”¾èˆ‡å‰ªè¼¯å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #fafafa;
            border-radius: 10px;
            border: 1px solid #eee;
        }

        .section-title {
            font-size: 1.3rem;
            color: #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .file-upload-area {
            border: 3px dashed #bbb;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-icon {
            font-size: 3rem;
            color: #bbb;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1rem;
            color: #666;
        }

        input[type="file"] {
            display: none;
        }

        .file-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin-top: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            outline: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* å¼·åˆ¶å‰é€²å¾Œé€€æŒ‰éˆ•å§‹çµ‚å¯é»æ“Š */
        #rewindBtn, #forwardBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            cursor: pointer !important;
            pointer-events: auto !important;
        }
        
        #rewindBtn:hover, #forwardBtn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4) !important;
        }

        .progress-container {
            background: #eee;
            border-radius: 25px;
            padding: 3px;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .progress-bar::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .time-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 15px;
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .trim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .trim-input {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .trim-input label {
            font-weight: bold;
            color: #555;
        }

        .trim-input input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .trim-input input:focus {
            border-color: #667eea;
        }

        .download-section {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .download-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            font-size: 1.1rem;
            padding: 15px 30px;
        }

        .download-btn:hover {
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            margin: 10px 0;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
            margin: 10px 0;
        }

        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .trim-controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ MP3 æ’­æ”¾èˆ‡å‰ªè¼¯å·¥å…·</h1>
            <p>ä¸Šå‚³éŸ³æª”ã€æ’­æ”¾ã€å‰ªè¼¯ï¼Œç„¶å¾Œä¸‹è¼‰æ‚¨çš„ä½œå“</p>
        </div>

        <div class="content">
            <!-- æª”æ¡ˆä¸Šå‚³å€ -->
            <div class="section">
                <h2 class="section-title">ğŸ“ ä¸Šå‚³éŸ³æª”</h2>
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ§</div>
                    <div class="upload-text">
                        <strong>é»æ“Šæˆ–æ‹–æ‹½ MP3 æª”æ¡ˆåˆ°é€™è£¡</strong><br>
                        æ”¯æ´æ ¼å¼ï¼šMP3, WAV, M4A
                    </div>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>
                <div id="fileInfo" class="file-info" style="display: none;">
                    <div id="fileName"></div>
                    <div id="fileDuration"></div>
                </div>
                <div id="errorMessage" class="error-message" style="display: none;"></div>
            </div>

            <!-- æ’­æ”¾æ§åˆ¶å€ -->
            <div class="section" id="playerSection" style="display: none;">
                <h2 class="section-title">ğŸ® æ’­æ”¾æ§åˆ¶</h2>
                
                <div class="controls">
                    <button class="btn" id="playBtn">â–¶ï¸ æ’­æ”¾</button>
                    <button class="btn" id="pauseBtn" disabled>â¸ï¸ æš«åœ</button>
                    <button class="btn" id="rewindBtn">âª -5ç§’</button>
                    <button class="btn" id="forwardBtn">â© +5ç§’</button>
                </div>

                <div class="progress-container">
                    <input type="range" class="progress-bar" id="progressBar" min="0" max="100" value="0">
                </div>

                <!-- æ³¢å½¢å¯è¦–åŒ– -->
                <canvas id="waveform" width="720" height="100" style="width: 100%; height: 100px; background: #f8f9fa; border-radius: 8px; margin: 10px 0;"></canvas>

                <div class="time-info">
                    <span id="currentTime">00:00</span>
                    <span id="totalTime">00:00</span>
                </div>

                <div class="volume-container">
                    <span>ğŸ”Š</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                    <span id="volumeValue">50%</span>
                </div>
            </div>

            <!-- å‰ªè¼¯æ§åˆ¶å€ -->
            <div class="section" id="trimSection" style="display: none;">
                <h2 class="section-title">âœ‚ï¸ å‰ªè¼¯è¨­å®š</h2>
                
                <div class="trim-controls">
                    <div class="trim-input">
                        <label for="startTime">é–‹å§‹æ™‚é–“ (ç§’)</label>
                        <input type="number" id="startTime" min="0" step="0.1" placeholder="0.0">
                    </div>
                    <div class="trim-input">
                        <label for="endTime">çµæŸæ™‚é–“ (ç§’)</label>
                        <input type="number" id="endTime" min="0" step="0.1" placeholder="10.0">
                    </div>
                </div>

                <div class="trim-controls">
                    <div class="trim-input">
                        <label for="fadeInTime">æ·¡å…¥æ™‚é–“ (ç§’)</label>
                        <input type="number" id="fadeInTime" min="0" max="5" step="0.1" value="0" placeholder="0.0">
                    </div>
                    <div class="trim-input">
                        <label for="fadeOutTime">æ·¡å‡ºæ™‚é–“ (ç§’)</label>
                        <input type="number" id="fadeOutTime" min="0" max="5" step="0.1" value="0" placeholder="0.0">
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" id="previewBtn">ğŸ” é è¦½å‰ªè¼¯</button>
                    <button class="btn" id="resetBtn">ğŸ”„ é‡ç½®</button>
                    <button class="btn" id="setStartBtn">ğŸ“ è¨­ç‚ºé–‹å§‹</button>
                    <button class="btn" id="setEndBtn">ğŸ“ è¨­ç‚ºçµæŸ</button>
                </div>
            </div>

            <!-- ä¸‹è¼‰å€ -->
            <div class="section" id="downloadSection" style="display: none;">
                <h2 class="section-title">ğŸ’¾ ä¸‹è¼‰å‰ªè¼¯</h2>
                <div class="download-section">
                    <button class="btn download-btn" id="downloadWavBtn">ğŸ“¥ ä¸‹è¼‰ WAV æª”æ¡ˆ</button>
                    <button class="btn download-btn" id="downloadMp3Btn" style="margin-left: 15px;">ğŸ“¥ ä¸‹è¼‰ MP3 æª”æ¡ˆ</button>
                </div>
                <div id="successMessage" class="success-message" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- åŠ å…¥ LameJS åº«ç”¨æ–¼ MP3 ç·¨ç¢¼ - 320kbps é«˜éŸ³è³ª -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    
    <script>
        // å…¨åŸŸè®Šæ•¸
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let gainNode;
        let isPlaying = false;
        let startOffset = 0; // ç•¶å‰æ’­æ”¾åç§»ï¼ˆç§’ï¼‰
        let startTime = 0;   // é–‹å§‹æ’­æ”¾çš„æ™‚é–“ï¼ˆcontext æ™‚é–“ï¼‰
        let animationId;
        let waveformData = null;
        let previewEndTime = null; // é è¦½æ¨¡å¼çš„çµæŸæ™‚é–“
        let fadeInTime = 0; // é è¦½æ·¡å…¥æ™‚é–“
        let fadeOutTime = 0; // é è¦½æ·¡å‡ºæ™‚é–“
        let previewStartTime = 0; // é è¦½é–‹å§‹æ™‚é–“

        // DOM å…ƒç´ 
        const uploadArea = document.getElementById('uploadArea');
        const audioFile = document.getElementById('audioFile');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileDuration = document.getElementById('fileDuration');
        const errorMessage = document.getElementById('errorMessage');
        const successMessage = document.getElementById('successMessage');
        
        const playerSection = document.getElementById('playerSection');
        const trimSection = document.getElementById('trimSection');
        const downloadSection = document.getElementById('downloadSection');
        
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');
        const fadeInTimeInput = document.getElementById('fadeInTime');
        const fadeOutTimeInput = document.getElementById('fadeOutTime');
        const previewBtn = document.getElementById('previewBtn');
        const resetBtn = document.getElementById('resetBtn');
        const setStartBtn = document.getElementById('setStartBtn');
        const setEndBtn = document.getElementById('setEndBtn');
        const downloadWavBtn = document.getElementById('downloadWavBtn');
        const downloadMp3Btn = document.getElementById('downloadMp3Btn');
        const waveformCanvas = document.getElementById('waveform');

        // åˆå§‹åŒ– AudioContext
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0.5; // é è¨­éŸ³é‡ 50%
            }
        }

        // æª¢æŸ¥ LameJS åº«åŠ è¼‰ç‹€æ…‹
        function checkLameJS() {
            if (typeof lamejs === 'undefined') {
                console.warn('LameJS åº«æœªåŠ è¼‰ï¼ŒMP3åŠŸèƒ½å°‡ä¸å¯ç”¨');
                return false;
            } else {
                console.log('LameJS åº«å·²åŠ è¼‰ï¼Œæ”¯æ´MP3ç·¨ç¢¼');
                return true;
            }
        }

        // é é¢åŠ è¼‰å®Œæˆå¾Œæª¢æŸ¥
        window.addEventListener('load', () => {
            setTimeout(checkLameJS, 1000); // å»¶é²æª¢æŸ¥ç¢ºä¿åº«å·²åŠ è¼‰
        });
        

        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 5000);
        }

        // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        function showSuccess(message) {
            successMessage.textContent = message;
            successMessage.style.display = 'block';
            setTimeout(() => {
                successMessage.style.display = 'none';
            }, 3000);
        }

        // ç”Ÿæˆæ³¢å½¢æ•¸æ“š
        function generateWaveformData(buffer, width = 720) {
            const channelData = buffer.getChannelData(0); // ä½¿ç”¨ç¬¬ä¸€å€‹è²é“
            const samplesPerPixel = Math.floor(channelData.length / width);
            const waveform = new Array(width);
            
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                
                for (let j = 0; j < samplesPerPixel; j++) {
                    const sample = channelData[i * samplesPerPixel + j] || 0;
                    if (sample < min) min = sample;
                    if (sample > max) max = sample;
                }
                
                waveform[i] = { min, max };
            }
            
            return waveform;
        }

        // ç¹ªè£½æ³¢å½¢
        function drawWaveform(waveform, currentProgress = 0) {
            if (!waveformCanvas) return;
            
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;
            
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // ç¹ªè£½èƒŒæ™¯æ³¢å½¢ï¼ˆç°è‰²ï¼‰
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < waveform.length; i++) {
                const x = (i / waveform.length) * width;
                const yMin = centerY + (waveform[i].min * centerY * 0.8);
                const yMax = centerY + (waveform[i].max * centerY * 0.8);
                
                ctx.moveTo(x, yMin);
                ctx.lineTo(x, yMax);
            }
            ctx.stroke();
            
            // ç¹ªè£½å·²æ’­æ”¾éƒ¨åˆ†ï¼ˆè—è‰²ï¼‰
            const playedWidth = width * currentProgress;
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < waveform.length && (i / waveform.length) * width <= playedWidth; i++) {
                const x = (i / waveform.length) * width;
                const yMin = centerY + (waveform[i].min * centerY * 0.8);
                const yMax = centerY + (waveform[i].max * centerY * 0.8);
                
                ctx.moveTo(x, yMin);
                ctx.lineTo(x, yMax);
            }
            ctx.stroke();
            
            // ç¹ªè£½æ’­æ”¾ä½ç½®æŒ‡ç¤ºç·š
            if (currentProgress > 0) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playedWidth, 0);
                ctx.lineTo(playedWidth, height);
                ctx.stroke();
            }
        }

        // æª”æ¡ˆæ‹–æ‹½è™•ç†
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            audioFile.click();
        });

        audioFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // è™•ç†ä¸Šå‚³çš„æª”æ¡ˆ
        async function handleFile(file) {
            if (!file.type.startsWith('audio/')) {
                showError('è«‹é¸æ“‡éŸ³è¨Šæª”æ¡ˆï¼');
                return;
            }

            try {
                initAudioContext();
                
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // ç”Ÿæˆæ³¢å½¢æ•¸æ“š
                waveformData = generateWaveformData(audioBuffer);
                drawWaveform(waveformData, 0);
                
                // é¡¯ç¤ºæª”æ¡ˆè³‡è¨Š
                fileName.textContent = `æª”æ¡ˆï¼š${file.name}`;
                fileDuration.textContent = `é•·åº¦ï¼š${formatTime(audioBuffer.duration)}`;
                fileInfo.style.display = 'block';
                
                // è¨­å®šé è¨­å‰ªè¼¯æ™‚é–“
                startTimeInput.max = audioBuffer.duration;
                endTimeInput.max = audioBuffer.duration;
                endTimeInput.value = Math.min(10, audioBuffer.duration);
                
                // æ›´æ–°é€²åº¦æ¢æœ€å¤§å€¼
                progressBar.max = 100;
                totalTime.textContent = formatTime(audioBuffer.duration);
                
                // é¡¯ç¤ºæ§åˆ¶å€åŸŸ
                playerSection.style.display = 'block';
                trimSection.style.display = 'block';
                downloadSection.style.display = 'block';
                
                // ç¢ºä¿æ‰€æœ‰æ§åˆ¶æŒ‰éˆ•çš„åˆå§‹ç‹€æ…‹æ­£ç¢º
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
            } catch (error) {
                console.error('éŸ³è¨Šè§£ç¢¼éŒ¯èª¤:', error);
                showError('éŸ³è¨Šæª”æ¡ˆæ ¼å¼ä¸æ”¯æ´æˆ–æª”æ¡ˆæå£ï¼');
            }
        }

        // å¼·åˆ¶åœæ­¢ä¸¦æ¸…ç† sourceNode - ç¢ºä¿æ°¸é åªæœ‰ä¸€å€‹éŸ³è»Œ
        function forceStopSourceNode() {
            console.log('åŸ·è¡Œå¼·åˆ¶åœæ­¢ - sourceNodeå­˜åœ¨:', !!sourceNode, 'isPlaying:', isPlaying);
            
            if (sourceNode) {
                try {
                    // ç§»é™¤äº‹ä»¶ç›£è½å™¨é˜²æ­¢æ„å¤–è§¸ç™¼
                    sourceNode.onended = null;
                    sourceNode.stop();
                    console.log('sourceNode.stop() æˆåŠŸ');
                } catch (e) {
                    console.warn('sourceNode åœæ­¢å¤±æ•—:', e);
                }
                
                try {
                    sourceNode.disconnect();
                    console.log('sourceNode.disconnect() æˆåŠŸ');
                } catch (e) {
                    console.warn('sourceNode æ–·é€£å¤±æ•—:', e);
                }
                
                sourceNode = null;
                console.log('sourceNode å·²è¨­ç‚º null');
            }
            
            // å¼·åˆ¶é‡ç½®ç‹€æ…‹
            isPlaying = false;
            cancelAnimationFrame(animationId);
            
            console.log('éŸ³è»Œæ¸…ç†å®Œæˆ - ç¢ºä¿åªæœ‰ä¸€å€‹éŸ³è»Œ');
        }

        // æ’­æ”¾éŸ³è¨Š
        function playAudio(offset = startOffset) {
            if (!audioBuffer) return;

            // 1. å…ˆæª¢æŸ¥ä¸¦å¼·åˆ¶åœæ­¢èˆŠçš„ sourceNode
            forceStopSourceNode();
            
            try {
                // 2. å»ºç«‹æ–°çš„ AudioBufferSourceNode
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(gainNode);
                
                // 3. å¾æ­£ç¢ºçš„ offset é–‹å§‹æ’­æ”¾
                sourceNode.start(0, offset);
                
                // 4. è¨˜éŒ„é–‹å§‹æ™‚é–“å’Œåç§»
                startTime = audioContext.currentTime;
                startOffset = offset;
                isPlaying = true;
                
                // 5. æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
                // 6. é–‹å§‹æ›´æ–°é€²åº¦
                updateProgress();
                
                // 7. æ’­æ”¾çµæŸæ™‚çš„è™•ç†
                sourceNode.onended = () => {
                    if (isPlaying && sourceNode) {
                        isPlaying = false;
                        playBtn.disabled = false;
                        pauseBtn.disabled = true;
                        sourceNode = null;
                        cancelAnimationFrame(animationId);
                    }
                };
            } catch (error) {
                console.error('æ’­æ”¾éŒ¯èª¤:', error);
                forceStopSourceNode();
                showError('æ’­æ”¾å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
            }
        }

        // é è¦½æ’­æ”¾ - å¸¶å³æ™‚æ·¡å…¥æ·¡å‡ºæ•ˆæœ
        function playAudioWithFade(offset, fadeInDuration = 0, fadeOutDuration = 0, endTime = null) {
            if (!audioBuffer) return;

            console.log(`é è¦½æ’­æ”¾: å¾${offset}s, æ·¡å…¥${fadeInDuration}s, æ·¡å‡º${fadeOutDuration}s`);

            // 1. å…ˆæª¢æŸ¥ä¸¦å¼·åˆ¶åœæ­¢èˆŠçš„ sourceNode
            forceStopSourceNode();
            
            try {
                // 2. å»ºç«‹æ–°çš„ AudioBufferSourceNode
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(gainNode);
                
                // 3. è¨­å®šæ·¡å…¥æ•ˆæœ
                if (fadeInDuration > 0) {
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(
                        parseFloat(volumeSlider.value) / 100, 
                        audioContext.currentTime + fadeInDuration
                    );
                } else {
                    gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
                }
                
                // 4. è¨­å®šæ·¡å‡ºæ•ˆæœ
                if (fadeOutDuration > 0 && endTime) {
                    const fadeOutStartTime = audioContext.currentTime + (endTime - offset) - fadeOutDuration;
                    if (fadeOutStartTime > audioContext.currentTime) {
                        gainNode.gain.setValueAtTime(
                            parseFloat(volumeSlider.value) / 100, 
                            fadeOutStartTime
                        );
                        gainNode.gain.linearRampToValueAtTime(0, fadeOutStartTime + fadeOutDuration);
                    }
                }
                
                // 5. å¾æ­£ç¢ºçš„ offset é–‹å§‹æ’­æ”¾
                sourceNode.start(0, offset);
                
                // 6. è¨˜éŒ„é–‹å§‹æ™‚é–“å’Œåç§»
                startTime = audioContext.currentTime;
                startOffset = offset;
                isPlaying = true;
                
                // 7. æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                rewindBtn.disabled = false;
                forwardBtn.disabled = false;
                
                // 8. é–‹å§‹æ›´æ–°é€²åº¦
                updateProgress();
                
                // 9. æ’­æ”¾çµæŸæ™‚çš„è™•ç†
                sourceNode.onended = () => {
                    if (isPlaying && sourceNode) {
                        isPlaying = false;
                        playBtn.disabled = false;
                        pauseBtn.disabled = true;
                        sourceNode = null;
                        // æ¢å¾©åŸå§‹éŸ³é‡
                        gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
                        cancelAnimationFrame(animationId);
                    }
                };
            } catch (error) {
                console.error('é è¦½æ’­æ”¾éŒ¯èª¤:', error);
                forceStopSourceNode();
                showError('é è¦½æ’­æ”¾å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
            }
        }

        // æš«åœéŸ³è¨Š - å¼·åˆ¶åœæ­¢æ‰€æœ‰éŸ³è»Œ
        function pauseAudio() {
            // 1. ç„¡è«–ä»€éº¼ç‹€æ…‹ï¼Œéƒ½å¼·åˆ¶åœæ­¢æ‰€æœ‰éŸ³è»Œ
            if (isPlaying && sourceNode) {
                // è¨ˆç®—ç•¶å‰æ’­æ”¾ä½ç½®
                startOffset += audioContext.currentTime - startTime;
            }
            
            // 2. æ¸…é™¤é è¦½æ¨¡å¼
            previewEndTime = null;
            fadeInTime = 0;
            fadeOutTime = 0;
            previewStartTime = 0;
            
            // 3. æ¢å¾©æ­£å¸¸éŸ³é‡
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(parseFloat(volumeSlider.value) / 100, audioContext.currentTime);
            }
            
            // 4. å¼·åˆ¶åœæ­¢ä¸¦æ¸…ç†
            forceStopSourceNode();
            
            // 5. ç¢ºä¿ç‹€æ…‹æ­£ç¢º
            isPlaying = false;
            
            // 6. æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
            forwardBtn.disabled = false;
            
            console.log('æš«åœå®Œæˆ - æ‰€æœ‰éŸ³è»Œå·²åœæ­¢ï¼ŒéŸ³é‡å·²æ¢å¾©');
        }

        // åœæ­¢éŸ³è¨Š
        function stopAudio() {
            // 1. æ¸…é™¤é è¦½æ¨¡å¼
            previewEndTime = null;
            
            // 2. å¼·åˆ¶åœæ­¢ sourceNode
            forceStopSourceNode();
            
            // 3. é‡ç½®æ’­æ”¾ä½ç½®
            startOffset = 0;
            startTime = 0;
            
            // 4. æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
            forwardBtn.disabled = false;
            
            // 5. é‡ç½®UIé¡¯ç¤º
            progressBar.value = 0;
            currentTime.textContent = '00:00';
            
            // 6. é‡ç¹ªæ³¢å½¢ï¼ˆç§»é™¤æ’­æ”¾æŒ‡ç¤ºç·šï¼‰
            if (waveformData) {
                drawWaveform(waveformData, 0);
            }
        }

        // æ›´æ–°æ’­æ”¾é€²åº¦
        function updateProgress() {
            if (!isPlaying || !audioBuffer) return;
            
            const elapsed = audioContext.currentTime - startTime + startOffset;
            const progress = elapsed / audioBuffer.duration;
            progressBar.value = progress * 100;
            currentTime.textContent = formatTime(elapsed);
            
            // æ›´æ–°æ³¢å½¢é¡¯ç¤º
            if (waveformData) {
                drawWaveform(waveformData, progress);
            }
            
            // æª¢æŸ¥æ˜¯å¦åˆ°é”é è¦½çµæŸæ™‚é–“
            if (previewEndTime !== null && elapsed >= previewEndTime) {
                console.log('é è¦½åˆ°é”çµæŸæ™‚é–“ï¼Œè‡ªå‹•æš«åœ');
                previewEndTime = null; // æ¸…é™¤é è¦½æ¨¡å¼
                pauseAudio();
                return;
            }
            
            if (elapsed < audioBuffer.duration && isPlaying) {
                animationId = requestAnimationFrame(updateProgress);
            }
        }

        // é€²åº¦æ¢æ‹–æ‹½ - æ‹–æ›³æ™‚å¿…é ˆæš«åœæ‰€æœ‰éŸ³è»Œ
        progressBar.addEventListener('input', (e) => {
            if (!audioBuffer) return;
            
            const newTime = (parseFloat(e.target.value) / 100) * audioBuffer.duration;
            const wasPlaying = isPlaying;
            
            console.log('é€²åº¦æ¢æ‹–æ›³ - å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ');
            
            // 1. å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œï¼ˆä¸è«–ä¹‹å‰ç‹€æ…‹ï¼‰
            pauseAudio();
            
            // 2. æ›´æ–°ä½ç½®åˆ°æ‹–æ›³çš„ä½ç½®
            startOffset = newTime;
            currentTime.textContent = formatTime(newTime);
            
            // 3. æ›´æ–°æ³¢å½¢é¡¯ç¤º
            if (waveformData) {
                drawWaveform(waveformData, newTime / audioBuffer.duration);
            }
            
            // 4. å¦‚æœä¹‹å‰æ­£åœ¨æ’­æ”¾ï¼Œé‡æ–°é–‹å§‹æ’­æ”¾
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newTime);
                }, 10); // çŸ­æš«å»¶é²ç¢ºä¿æ¸…ç†å®Œæˆ
            }
        });

        // æ³¢å½¢canvasé»æ“Šè·³è½‰ - é»æ“Šæ™‚å¿…é ˆæš«åœæ‰€æœ‰éŸ³è»Œ
        waveformCanvas.addEventListener('click', (e) => {
            if (!audioBuffer || !waveformData) return;
            
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const progress = x / rect.width;
            const newTime = progress * audioBuffer.duration;
            const wasPlaying = isPlaying;
            
            console.log('æ³¢å½¢é»æ“Š - å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ');
            
            // 1. å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ
            pauseAudio();
            
            // 2. æ›´æ–°ä½ç½®å’ŒUI
            startOffset = newTime;
            progressBar.value = progress * 100;
            currentTime.textContent = formatTime(newTime);
            drawWaveform(waveformData, progress);
            
            // 3. å¦‚æœä¹‹å‰æ­£åœ¨æ’­æ”¾ï¼Œé‡æ–°é–‹å§‹æ’­æ”¾
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newTime);
                }, 10); // çŸ­æš«å»¶é²ç¢ºä¿æ¸…ç†å®Œæˆ
            }
        });

        // éŸ³é‡æ§åˆ¶ - åªèª¿æ•´ GainNodeï¼Œä¸é‡å»º sourceNode
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            volumeValue.textContent = e.target.value + '%';
            
            // ç›´æ¥èª¿æ•´ GainNode çš„éŸ³é‡ï¼Œä¸éœ€è¦åœæ­¢æˆ–é‡å»º sourceNode
            if (gainNode) {
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            }
        });

        // æ’­æ”¾æ§åˆ¶äº‹ä»¶
        playBtn.addEventListener('click', () => {
            // åš´æ ¼æª¢æŸ¥ï¼šåªæœ‰åœ¨å®Œå…¨æ²’æœ‰æ’­æ”¾æ™‚æ‰å…è¨±
            if (!isPlaying && !sourceNode && !playBtn.disabled) {
                console.log('é–‹å§‹æ’­æ”¾');
                // æ¸…é™¤é è¦½æ¨¡å¼ï¼Œæ¢å¾©æ­£å¸¸æ’­æ”¾
                previewEndTime = null;
                playAudio();
            } else {
                console.log('æ’­æ”¾è¢«é˜»æ­¢ - å·²æœ‰éŸ³è»Œåœ¨æ’­æ”¾');
            }
        });

        pauseBtn.addEventListener('click', () => {
            console.log('æš«åœæŒ‰éˆ•è¢«é»æ“Š');
            pauseAudio(); // ç„¡æ¢ä»¶åŸ·è¡Œæš«åœ
        });
        
        // å¾Œé€€5ç§’
        rewindBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('è«‹å…ˆä¸Šå‚³éŸ³æª”ï¼');
                return;
            }
            
            console.log('å¾Œé€€5ç§’ - é–‹å§‹è™•ç†');
            
            // 1. è¨ˆç®—ç•¶å‰ä½ç½®
            let currentPos = startOffset;
            const wasPlaying = isPlaying;
            if (sourceNode && isPlaying) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            // 2. å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ
            pauseAudio();
            
            // 3. è¨ˆç®—æ–°çš„ä½ç½®
            let newOffset = currentPos - 5;
            if (newOffset < 0) newOffset = 0;
            
            // 4. æ›´æ–°UIç‹€æ…‹
            startOffset = newOffset;
            progressBar.value = (newOffset / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(newOffset);
            if (waveformData) {
                drawWaveform(waveformData, newOffset / audioBuffer.duration);
            }
            
            // 5. å¦‚æœä¹‹å‰åœ¨æ’­æ”¾ï¼Œé‡æ–°æ’­æ”¾
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newOffset);
                }, 10);
            }
        });
        
        // å‰é€²5ç§’
        forwardBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('è«‹å…ˆä¸Šå‚³éŸ³æª”ï¼');
                return;
            }
            
            console.log('å‰é€²5ç§’ - é–‹å§‹è™•ç†');
            
            // 1. è¨ˆç®—ç•¶å‰ä½ç½®
            let currentPos = startOffset;
            const wasPlaying = isPlaying;
            if (sourceNode && isPlaying) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            // 2. å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ
            pauseAudio();
            
            // 3. è¨ˆç®—æ–°çš„ä½ç½®
            let newOffset = currentPos + 5;
            if (newOffset >= audioBuffer.duration) newOffset = audioBuffer.duration - 0.1;
            
            // 4. æ›´æ–°UIç‹€æ…‹
            startOffset = newOffset;
            progressBar.value = (newOffset / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(newOffset);
            if (waveformData) {
                drawWaveform(waveformData, newOffset / audioBuffer.duration);
            }
            
            // 5. å¦‚æœä¹‹å‰åœ¨æ’­æ”¾ï¼Œé‡æ–°æ’­æ”¾
            if (wasPlaying) {
                setTimeout(() => {
                    playAudio(newOffset);
                }, 10);
            }
        });

        // é è¦½å‰ªè¼¯ - è·³åˆ°å‰ªè¼¯é–‹å§‹æ™‚é–“ä¸¦æ’­æ”¾ï¼Œå¸¶æ·¡å…¥æ·¡å‡ºæ•ˆæœï¼Œåˆ°çµæŸæ™‚é–“è‡ªå‹•æš«åœ
        previewBtn.addEventListener('click', () => {
            if (!audioBuffer) {
                showError('è«‹å…ˆä¸Šå‚³éŸ³æª”ï¼');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            const fadeIn = parseFloat(fadeInTimeInput.value) || 0;
            const fadeOut = parseFloat(fadeOutTimeInput.value) || 0;
            
            if (start >= end) {
                showError('é–‹å§‹æ™‚é–“å¿…é ˆå°æ–¼çµæŸæ™‚é–“ï¼');
                return;
            }
            
            if (end > audioBuffer.duration) {
                showError('çµæŸæ™‚é–“ä¸èƒ½è¶…ééŸ³æª”é•·åº¦ï¼');
                return;
            }
            
            console.log(`é è¦½å‰ªè¼¯ - å¾ ${start.toFixed(1)}s åˆ° ${end.toFixed(1)}s (æ·¡å…¥${fadeIn}s, æ·¡å‡º${fadeOut}s)`);
            
            // 1. å¼·åˆ¶æš«åœæ‰€æœ‰éŸ³è»Œ
            pauseAudio();
            
            // 2. è¨­å®šé è¦½åƒæ•¸
            previewEndTime = end;
            previewStartTime = start;
            fadeInTime = fadeIn;
            fadeOutTime = fadeOut;
            
            // 3. è·³åˆ°å‰ªè¼¯é–‹å§‹æ™‚é–“
            startOffset = start;
            progressBar.value = (start / audioBuffer.duration) * 100;
            currentTime.textContent = formatTime(start);
            if (waveformData) {
                drawWaveform(waveformData, start / audioBuffer.duration);
            }
            
            // 4. é–‹å§‹æ’­æ”¾å‰ªè¼¯æ®µè½ï¼ˆå¸¶æ·¡å…¥æ·¡å‡ºæ•ˆæœï¼‰
            setTimeout(() => {
                playAudioWithFade(start, fadeIn, fadeOut, end);
            }, 10);
        });

        // é‡ç½®å‰ªè¼¯è¨­å®š
        resetBtn.addEventListener('click', () => {
            console.log('é‡ç½®å‰ªè¼¯è¨­å®š');
            
            // 1. é‡ç½®å‰ªè¼¯åƒæ•¸
            startTimeInput.value = 0;
            endTimeInput.value = Math.min(10, audioBuffer ? audioBuffer.duration : 10);
            fadeInTimeInput.value = 0;
            fadeOutTimeInput.value = 0;
            
            // 2. åœæ­¢éŸ³è»Œä¸¦é‡ç½®åˆ°é–‹é ­
            stopAudio();
        });
        
        // è¨­å®šç•¶å‰æ™‚é–“ç‚ºé–‹å§‹æ™‚é–“
        setStartBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            
            // è¨ˆç®—ç•¶å‰æ’­æ”¾ä½ç½®
            let currentPos = startOffset;
            if (isPlaying && sourceNode) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            startTimeInput.value = Math.max(0, currentPos).toFixed(1);
            console.log('è¨­å®šé–‹å§‹æ™‚é–“ç‚º:', currentPos.toFixed(1));
        });
        
        // è¨­å®šç•¶å‰æ™‚é–“ç‚ºçµæŸæ™‚é–“
        setEndBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            
            // è¨ˆç®—ç•¶å‰æ’­æ”¾ä½ç½®
            let currentPos = startOffset;
            if (isPlaying && sourceNode) {
                currentPos += audioContext.currentTime - startTime;
            }
            
            endTimeInput.value = Math.min(audioBuffer.duration, currentPos).toFixed(1);
            console.log('è¨­å®šçµæŸæ™‚é–“ç‚º:', currentPos.toFixed(1));
        });

        // ä¸‹è¼‰å‰ªè¼¯éŸ³æª” (WAV)
        downloadWavBtn.addEventListener('click', async () => {
            if (!audioBuffer) {
                showError('è«‹å…ˆä¸Šå‚³éŸ³æª”ï¼');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            
            if (start >= end) {
                showError('é–‹å§‹æ™‚é–“å¿…é ˆå°æ–¼çµæŸæ™‚é–“ï¼');
                return;
            }
            
            try {
                // å»ºç«‹æ–°çš„ AudioBuffer åŒ…å«å‰ªè¼¯éƒ¨åˆ†
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                const trimmedLength = endSample - startSample;
                
                console.log(`WAVä¸‹è¼‰: é–‹å§‹æ¨£æœ¬=${startSample}, çµæŸæ¨£æœ¬=${endSample}, é•·åº¦=${trimmedLength}`);
                
                if (trimmedLength <= 0) {
                    showError('å‰ªè¼¯é•·åº¦ç„¡æ•ˆï¼');
                    return;
                }
                
                const trimmedBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    trimmedLength,
                    audioBuffer.sampleRate
                );
                
                let maxSample = 0;
                
                // è¤‡è£½éŸ³è¨Šè³‡æ–™
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const originalData = audioBuffer.getChannelData(channel);
                    const trimmedData = trimmedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < trimmedLength; i++) {
                        const sourceIndex = startSample + i;
                        if (sourceIndex < originalData.length) {
                            trimmedData[i] = originalData[sourceIndex];
                            maxSample = Math.max(maxSample, Math.abs(trimmedData[i]));
                        }
                    }
                }
                
                console.log(`éŸ³é »è¤‡è£½å®Œæˆ: æœ€å¤§æ¨£æœ¬å€¼=${maxSample.toFixed(4)}`);
                
                // æ‡‰ç”¨æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                const fadeInDuration = parseFloat(fadeInTimeInput.value) || 0;
                const fadeOutDuration = parseFloat(fadeOutTimeInput.value) || 0;
                
                let processedBuffer = trimmedBuffer;
                if (fadeInDuration > 0 || fadeOutDuration > 0) {
                    processedBuffer = applyFadeEffect(trimmedBuffer, fadeInDuration, fadeOutDuration);
                }
                
                // è½‰æ›ç‚º WAV æ ¼å¼
                const wavBlob = audioBufferToWav(processedBuffer);
                
                // å»ºç«‹ä¸‹è¼‰é€£çµ
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `trimmed_audio_${Date.now()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showSuccess('éŸ³æª”ä¸‹è¼‰æˆåŠŸï¼');
                
            } catch (error) {
                console.error('ä¸‹è¼‰éŒ¯èª¤:', error);
                showError('ä¸‹è¼‰å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
            }
        });

        // å°‡ AudioBuffer è½‰æ›ç‚º WAV Blob
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const numberOfChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(arrayBuffer);
            
            console.log(`è½‰æ›WAV: é•·åº¦=${length}, è²é“=${numberOfChannels}, æ¡æ¨£ç‡=${sampleRate}`);
            
            // WAV æª”æ¡ˆæ¨™é ­
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);
            
            // éŸ³è¨Šè³‡æ–™ - ä¿®å¾©éŸ³é »æ•¸æ“šè½‰æ›
            let offset = 44;
            let maxSample = 0;
            
            if (numberOfChannels === 1) {
                // å–®è²é“
                const channelData = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    maxSample = Math.max(maxSample, Math.abs(sample));
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            } else {
                // å¤šè²é“ - äº¤éŒ¯æ’åˆ—
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        maxSample = Math.max(maxSample, Math.abs(sample));
                        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, intSample, true);
                        offset += 2;
                    }
                }
            }
            
            console.log(`WAVè½‰æ›å®Œæˆ: æœ€å¤§éŸ³é »å€¼=${maxSample.toFixed(4)}`);
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        // æ‡‰ç”¨æ·¡å…¥æ·¡å‡ºæ•ˆæœ
        function applyFadeEffect(buffer, fadeInDuration, fadeOutDuration) {
            const sampleRate = buffer.sampleRate;
            const fadeInSamples = Math.floor(fadeInDuration * sampleRate);
            const fadeOutSamples = Math.floor(fadeOutDuration * sampleRate);
            const totalSamples = buffer.length;
            
            console.log(`æ‡‰ç”¨æ·¡å…¥æ·¡å‡º: æ·¡å…¥${fadeInSamples}æ¨£æœ¬, æ·¡å‡º${fadeOutSamples}æ¨£æœ¬, ç¸½é•·${totalSamples}æ¨£æœ¬`);
            
            // å‰µå»ºä¸€å€‹æ–°çš„bufferå‰¯æœ¬
            const newBuffer = audioContext.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );
            
            let maxOriginal = 0;
            let maxProcessed = 0;
            
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const originalData = buffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                for (let i = 0; i < totalSamples; i++) {
                    let sample = originalData[i];
                    maxOriginal = Math.max(maxOriginal, Math.abs(sample));
                    
                    // æ·¡å…¥æ•ˆæœ
                    if (i < fadeInSamples && fadeInSamples > 0) {
                        const fadeInGain = i / fadeInSamples;
                        sample *= fadeInGain;
                    }
                    
                    // æ·¡å‡ºæ•ˆæœ
                    if (i >= (totalSamples - fadeOutSamples) && fadeOutSamples > 0) {
                        const fadeOutGain = (totalSamples - i) / fadeOutSamples;
                        sample *= fadeOutGain;
                    }
                    
                    newData[i] = sample;
                    maxProcessed = Math.max(maxProcessed, Math.abs(sample));
                }
            }
            
            console.log(`æ·¡å…¥æ·¡å‡ºè™•ç†å®Œæˆ: åŸå§‹æœ€å¤§å€¼=${maxOriginal.toFixed(4)}, è™•ç†å¾Œæœ€å¤§å€¼=${maxProcessed.toFixed(4)}`);
            
            return newBuffer;
        }
        
        // ä¸‹è¼‰å‰ªè¼¯éŸ³æª” (MP3)
        downloadMp3Btn.addEventListener('click', async () => {
            if (!audioBuffer) {
                showError('è«‹å…ˆä¸Šå‚³éŸ³æª”ï¼');
                return;
            }
            
            const start = parseFloat(startTimeInput.value) || 0;
            const end = parseFloat(endTimeInput.value) || audioBuffer.duration;
            
            if (start >= end) {
                showError('é–‹å§‹æ™‚é–“å¿…é ˆå°æ–¼çµæŸæ™‚é–“ï¼');
                return;
            }
            
            try {
                // å»ºç«‹æ–°çš„ AudioBuffer åŒ…å«å‰ªè¼¯éƒ¨åˆ†
                const startSample = Math.floor(start * audioBuffer.sampleRate);
                const endSample = Math.floor(end * audioBuffer.sampleRate);
                const trimmedLength = endSample - startSample;
                
                console.log(`MP3ä¸‹è¼‰: é–‹å§‹æ¨£æœ¬=${startSample}, çµæŸæ¨£æœ¬=${endSample}, é•·åº¦=${trimmedLength}`);
                
                if (trimmedLength <= 0) {
                    showError('å‰ªè¼¯é•·åº¦ç„¡æ•ˆï¼');
                    return;
                }
                
                const trimmedBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    trimmedLength,
                    audioBuffer.sampleRate
                );
                
                let maxSample = 0;
                
                // è¤‡è£½éŸ³è¨Šè³‡æ–™
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const originalData = audioBuffer.getChannelData(channel);
                    const trimmedData = trimmedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < trimmedLength; i++) {
                        const sourceIndex = startSample + i;
                        if (sourceIndex < originalData.length) {
                            trimmedData[i] = originalData[sourceIndex];
                            maxSample = Math.max(maxSample, Math.abs(trimmedData[i]));
                        }
                    }
                }
                
                console.log(`MP3éŸ³é »è¤‡è£½å®Œæˆ: æœ€å¤§æ¨£æœ¬å€¼=${maxSample.toFixed(4)}`);
                
                // æ‡‰ç”¨æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                const fadeInDuration = parseFloat(fadeInTimeInput.value) || 0;
                const fadeOutDuration = parseFloat(fadeOutTimeInput.value) || 0;
                
                let processedBuffer = trimmedBuffer;
                if (fadeInDuration > 0 || fadeOutDuration > 0) {
                    processedBuffer = applyFadeEffect(trimmedBuffer, fadeInDuration, fadeOutDuration);
                }
                
                // è½‰æ›ç‚º MP3 æ ¼å¼
                const mp3Blob = audioBufferToMp3(processedBuffer);
                
                // å»ºç«‹ä¸‹è¼‰é€£çµ
                const url = URL.createObjectURL(mp3Blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `trimmed_audio_${Date.now()}.mp3`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showSuccess('MP3 éŸ³æª”ä¸‹è¼‰æˆåŠŸï¼');
                
            } catch (error) {
                console.error('MP3 ä¸‹è¼‰éŒ¯èª¤:', error);
                showError('MP3 ä¸‹è¼‰å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
            }
        });
        
        // å°‡ AudioBuffer è½‰æ›ç‚º MP3 Blob - 320kbps é«˜éŸ³è³ª
        function audioBufferToMp3(buffer) {
            if (typeof lamejs === 'undefined') {
                console.warn('LameJS æœªåŠ è¼‰ï¼Œå°‡ä½¿ç”¨ WAV æ ¼å¼');
                return audioBufferToWav(buffer);
            }
            
            const sampleRate = buffer.sampleRate;
            const channels = buffer.numberOfChannels;
            const length = buffer.length;
            
            console.log(`MP3ç·¨ç¢¼é–‹å§‹: æ¡æ¨£ç‡=${sampleRate}, è²é“=${channels}, é•·åº¦=${length}, 320kbps`);
            
            // åˆå§‹åŒ– LAME ç·¨ç¢¼å™¨ - 320kbps é«˜éŸ³è³ª
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 320);
            const mp3Data = [];
            
            // è™•ç†éŸ³é »æ•¸æ“š
            const sampleBlockSize = 1152;
            let totalSamples = 0;
            
            if (channels === 1) {
                // å–®è²é“è™•ç†
                const channelData = buffer.getChannelData(0);
                let maxSample = 0;
                
                for (let i = 0; i < length; i += sampleBlockSize) {
                    const blockSize = Math.min(sampleBlockSize, length - i);
                    const samples = new Int16Array(blockSize);
                    
                    for (let j = 0; j < blockSize; j++) {
                        const sample = channelData[i + j];
                        maxSample = Math.max(maxSample, Math.abs(sample));
                        // è½‰æ›ç‚º 16 ä½æ•´æ•¸ï¼Œé˜²æ­¢å‰Šå³°
                        samples[j] = Math.round(Math.max(-1, Math.min(1, sample)) * 32767);
                    }
                    
                    const mp3buf = mp3encoder.encodeBuffer(samples);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                        totalSamples += blockSize;
                    }
                }
                
                console.log(`å–®è²é“ç·¨ç¢¼: æœ€å¤§æ¨£æœ¬=${maxSample.toFixed(4)}, è™•ç†æ¨£æœ¬=${totalSamples}`);
                
            } else {
                // ç«‹é«”è²è™•ç†
                const leftData = buffer.getChannelData(0);
                const rightData = buffer.getChannelData(1);
                let maxSampleL = 0, maxSampleR = 0;
                
                for (let i = 0; i < length; i += sampleBlockSize) {
                    const blockSize = Math.min(sampleBlockSize, length - i);
                    const leftSamples = new Int16Array(blockSize);
                    const rightSamples = new Int16Array(blockSize);
                    
                    for (let j = 0; j < blockSize; j++) {
                        const leftSample = leftData[i + j];
                        const rightSample = rightData[i + j];
                        
                        maxSampleL = Math.max(maxSampleL, Math.abs(leftSample));
                        maxSampleR = Math.max(maxSampleR, Math.abs(rightSample));
                        
                        // è½‰æ›ç‚º 16 ä½æ•´æ•¸ï¼Œé˜²æ­¢å‰Šå³°
                        leftSamples[j] = Math.round(Math.max(-1, Math.min(1, leftSample)) * 32767);
                        rightSamples[j] = Math.round(Math.max(-1, Math.min(1, rightSample)) * 32767);
                    }
                    
                    const mp3buf = mp3encoder.encodeBuffer(leftSamples, rightSamples);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                        totalSamples += blockSize;
                    }
                }
                
                console.log(`ç«‹é«”è²ç·¨ç¢¼: å·¦è²é“æœ€å¤§=${maxSampleL.toFixed(4)}, å³è²é“æœ€å¤§=${maxSampleR.toFixed(4)}, è™•ç†æ¨£æœ¬=${totalSamples}`);
            }
            
            // å®Œæˆç·¨ç¢¼
            const finalBuf = mp3encoder.flush();
            if (finalBuf.length > 0) {
                mp3Data.push(finalBuf);
            }
            
            console.log(`MP3ç·¨ç¢¼å®Œæˆ: ç”Ÿæˆ${mp3Data.length}å€‹æ•¸æ“šå¡Š`);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆæ•¸æ“š
            const totalBytes = mp3Data.reduce((sum, buf) => sum + buf.length, 0);
            console.log(`MP3ç¸½å¤§å°: ${totalBytes} bytes`);
            
            if (totalBytes === 0) {
                console.error('MP3ç·¨ç¢¼å¤±æ•—ï¼šæ²’æœ‰ç”Ÿæˆæœ‰æ•ˆæ•¸æ“š');
                showError('MP3ç·¨ç¢¼å¤±æ•—ï¼Œè«‹å˜—è©¦WAVæ ¼å¼');
                return audioBufferToWav(buffer);
            }
            
            // å‰µå»º MP3 Blob
            return new Blob(mp3Data, { type: 'audio/mpeg' });
        }
    </script>
</body>
</html>